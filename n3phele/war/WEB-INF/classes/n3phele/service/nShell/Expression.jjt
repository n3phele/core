options{  static = false;  NODE_FACTORY="n3phele.service.nShell.ExpressionNode";  NODE_CLASS="SelfCompilingNode";}PARSER_BEGIN(Expression)package n3phele.service.nShell;import java.util.HashMap;import java.util.Map;
/** * (C) Copyright 2010-2013. Nigel Cook. All rights reserved. * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. *  * Licensed under the terms described in LICENSE file that accompanied this code, (the "License"); you may not use this file * except in compliance with the License.  *  *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on  *  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the  *  specific language governing permissions and limitations under the License. */
public class Expression{
	public Expression(String s, int lineNo, int columnNo)	{		jj_input_stream = new SimpleCharStream(new java.io.StringReader(s), lineNo, columnNo);        jj_input_stream.setTabSize(4);        token_source = new ExpressionTokenManager(jj_input_stream);        token = new Token();        jj_ntk = -1;        jj_gen = 0;        for (int i = 0; i < 5; i++) jj_la1[i] = -1;	}	public void reInit(String s, int lineNo, int columnNo)	{	  	jj_input_stream.ReInit(new java.io.StringReader(s), lineNo, columnNo);	    token_source.ReInit(jj_input_stream);	    token = new Token();	    jj_ntk = -1;	    jjtree.reset();	    jj_gen = 0;	    for (int i = 0; i < 20; i++) jj_la1[i] = -1;	    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();	}}PARSER_END(Expression)SKIP :{     "\r"  |  " "  |  "\t"  |  "\n"  | < COMMENT: "#" (~["\n"])* >}// ----------------- Expression -------------------------------TOKEN : {    < REGEX: "$$regex(" >  | < MAX: "$$max(" >  | < MIN: "$$min(" >  | < LENGTH: "$$length(" >  | < ESCAPE: "$$escape(" >  | < UNESCAPE: "$$unescape(" >  | < STRING: "$$string(" >}TOKEN : { <INTEGER_LITERAL: <DECIMAL_LITERAL> | <HEX_LITERAL> | <OCTAL_LITERAL> >|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>|  <STRING_LITERAL: "\"" ( ~["\"","\\"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ))* "\"">}TOKEN : { <IDENTIFIER: "$$" <VARSTART> ( < VARREST > | ".")* >   | < #VARSTART: ["A"-"Z", "a"-"z"] >  | < #VARREST:  ["A"-"Z", "a"-"z", "0"-"9", "_"] >  | < #WHITESPACE: " " | "\t" >}void functionExpression() : { }{	(     < REGEX > conditionalExpression() "," conditionalExpression() "," conditionalExpression() ")" { jjtThis.jjtSetValue("regex"); }			| < MAX > conditionalExpression() "," conditionalExpression() ")" { jjtThis.jjtSetValue("max"); }		| < MIN > conditionalExpression() "," conditionalExpression() ")" { jjtThis.jjtSetValue("min"); }		| < LENGTH > (LOOKAHEAD(list()) list() | conditionalExpression()) ")" { jjtThis.jjtSetValue("length"); }	    | < STRING > list() "," conditionalExpression() "," conditionalExpression() ")" { jjtThis.jjtSetValue("string"); }		| < ESCAPE > conditionalExpression() ")" { jjtThis.jjtSetValue("escape"); }		| < UNESCAPE > conditionalExpression() ")" { jjtThis.jjtSetValue("unescape"); }	)}SimpleNode buildExpressionTree() #void : { SimpleNode t; }{  (  	t = conditionalExpression() < EOF>  )  {    return t;  }}SimpleNode conditionalExpression() : { jjtThis.isNoop(); }{	(	  logicalORExpression() [ "?" conditionalExpression() ":" conditionalExpression() ]	)	{	  return jjtThis;	}}void logicalORExpression() : { jjtThis.isNoop(); }{	logicalANDExpression() [ "|" logicalORExpression() ]}void logicalANDExpression() : { jjtThis.isNoop(); }{	equalityExpression() [ "&" logicalANDExpression() ]}void equalityExpression() : { String op; jjtThis.isNoop(); }{	relationalExpression() [ 	( "==" 								{ jjtThis.jjtSetValue("=="); }	| "!=" 								{ jjtThis.jjtSetValue("!="); }	) equalityExpression() 				]}void relationalExpression() : {String op; jjtThis.isNoop(); }{	additiveExpression() [ 	( "<"										{ jjtThis.jjtSetValue("<"); } 	| ">"										{ jjtThis.jjtSetValue(">"); } 	| "<="										{ jjtThis.jjtSetValue("<="); }	| ">="										{ jjtThis.jjtSetValue(">="); }	) relationalExpression() 						]}void additiveExpression() : { Token op; jjtThis.isNoop(); }{	multiplicativeExpression() 		[ ( op = "+" | op = "-" )  additiveExpression() 	{	  jjtThis.jjtSetValue(op.image);	}]}void multiplicativeExpression() : { jjtThis.isNoop(); }{	unaryExpression() [ 	       ( "*"			{ jjtThis.jjtSetValue("*"); }	       | "/" 			{ jjtThis.jjtSetValue("/"); }	       | "%" 			{ jjtThis.jjtSetValue("%"); }	       )	       multiplicativeExpression()			  ]}void unaryExpression() : { jjtThis.isNoop(); Token t; }{	(       primaryExpression() [  listIndexExpression() ]	| ( t = unaryOperator() unaryExpression() { jjtThis.jjtSetValue(t.image); jjtThis.notNoop();} )	)}Token unaryOperator() #void : {Token t;}{	( t = "+" 	| t = "-" 	| t = "~"	| t = "!"	)	{	  return t;	}}void primaryExpression() #void : {  }{	(    constant()	  | "(" conditionalExpression() ")"		  | functionExpression()	  | identifier()	)}void listIndexExpression() #void : {  }{	 "[" conditionalExpression()  "]"} void identifier() : { Token t; }{  (      t = < IDENTIFIER >  )	{	  jjtThis.jjtSetValue(t.image);	}}void primaryListExpression() #void : {  }{	   "(" list() ")" 	|  identifier()}void subList() : { jjtThis.isNoop(); }{	primaryListExpression() [ "[" conditionalExpression() "," conditionalExpression()  "]" ]}void list() : { jjtThis.isNoop();  }{	subList() [ "+"  list() ]}void constant() : {Token t;}{ 	( 	  t = <INTEGER_LITERAL> 		{ jjtThis.jjtSetValue(Long.decode(t.image)); }  	| t = <STRING_LITERAL>  		{ jjtThis.jjtSetValue(t.image.substring(1,t.image.length()-1)); } 	| t = <FLOATING_POINT_LITERAL>  { jjtThis.jjtSetValue(Double.valueOf(t.image)); } 	)}// -------------------------------------------------------