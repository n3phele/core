options{  static = false;  NODE_FACTORY="n3phele.service.nShell.ShellNode";}PARSER_BEGIN(Shell)package n3phele.service.nShell;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import n3phele.service.model.ShellFragment;
/** * (C) Copyright 2010-2013. Nigel Cook. All rights reserved. * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. *  * Licensed under the terms described in LICENSE file that accompanied this code, (the "License"); you may not use this file * except in compliance with the License.  *  *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on  *  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the  *  specific language governing permissions and limitations under the License. */
public class Shell{    protected Expression expressionHandler = null;
	public Shell(String s, int lineNo)	{	  	if(s.charAt(0) != '\n')	  	{	  	  	lineNo = lineNo -1;	  		s = "\n"+s;	   }		jj_input_stream = new SimpleCharStream(new java.io.StringReader(s), lineNo, 1);        jj_input_stream.setTabSize(4);        token_source = new ShellTokenManager(jj_input_stream);        token = new Token();        jj_ntk = -1;        jj_gen = 0;        for (int i = 0; i < 5; i++) jj_la1[i] = -1;	}	public Expression getExpressionHandler(String s, int lineNo, int columnNo)	{		if(expressionHandler == null)		{		  	return (expressionHandler = new Expression(s, lineNo, columnNo));		} else		{			expressionHandler.reInit(s, lineNo, columnNo);			return expressionHandler;		}			  	}    public SimpleNode getExpressionNode(String s, int lineNo, int columnNo) throws ParseException	{		Expression e = getExpressionHandler(s, lineNo, columnNo);	 	SimpleNode node = e.buildExpressionTree();	 	return node;    }	 public List<ShellFragment> compile() throws ParseException     {        List<ShellFragment> result = new ArrayList<ShellFragment>();        SelfCompilingNode s = script();        s.compile(result);        return result;     }	    }PARSER_END(Shell)//SPECIAL_TOKEN ://{//	< INDENT: "\n" ( " " | "\t" )+ >//  | < COMMENT: "#" (~["\n"])* >// }< fileListProcessing, DEFAULT, argProcessing, passThruProcessing, wrappedExpressionProcessing >SKIP :{     "\r"  |  "\n"  | < COMMENT: "#" (~["\n"])* >}< fileListProcessing, DEFAULT, argProcessing, passThruProcessing, wrappedExpressionProcessing >SPECIAL_TOKEN :{     < SPACE: ( " " | "\t" )+ >}< fileListProcessing, DEFAULT, argProcessing, passThruProcessing >SKIP :{   < EXPRESSIONWRAPPER: "$${" > : wrappedExpressionProcessing}// Shell primatives< passThruProcessing, DEFAULT >TOKEN :{	< ON: "ON" > : DEFAULT  | < CREATEVM: "CREATEVM" > : DEFAULT  | < FORLOOP: "FOR" > : DEFAULT  | < DESTROY: "DESTROY" > : DEFAULT  | < LOG: "LOG" > : DEFAULT  | < VARIABLEASSIGN: "$$" < VARSTART > (< VARREST >)* (< WHITESPACE >)* "=" (< WHITESPACE >)* > { String s = image.toString().trim(); matchedToken.image = s.substring(0, s.length()-1).trim(); } : DEFAULT  | < #VARSTART: ["A"-"Z", "a"-"z"] >  | < #VARREST:  ["A"-"Z", "a"-"z", "0"-"9", "_"] >  | < #WHITESPACE: " " | "\t" >}TOKEN :{    < NO_ARG_OPTION: ("--nowait" | "--wait" | "--needsAll" | "--needsNone" | "--producesAll" | "--producesNone" ) > { String ss = image.toString(); matchedToken.image = ss.substring(2); }  | < OPTION: "--" < OPTIONSTART > (< OPTIONREST >)* > { matchedToken.image = image.toString().substring(2); } : argProcessing   | < #OPTIONSTART: ["a"-"z"] >  | < #OPTIONREST: ["A"-"Z", "a"-"z", "0"-"9"] >}< argProcessing >TOKEN :{    < NON_SPACE_ARG : < ARGSTART > (< ARGREST >)* > : DEFAULT  | < #ARGSTART: ["A"-"Z", "a"-"z", "0"-"9", ".", "_", "/"]  >  | < #ARGREST:  ~[" ", "\n"] >  | < LITERAL_STRING : < STRING_LITERAL > > { matchedToken.image = image.toString() ;									  matchedToken.image = n3phele.service.n.helpers.StringEscapeUtils.unescapeJavaString(matchedToken.image.substring(1,matchedToken.image.length()-1));									} : DEFAULT    | < FILELIST : "["  > : fileListProcessing }< fileListProcessing >TOKEN :{	< FILESPEC: <FILESTART> (<FILEREST>)* >	|  <#FILESTART: ["A"-"Z","a"-"z","0"-"9","_","-","."]>	|  <#FILEREST: ["A"-"Z","a"-"z","0"-"9","_","-",".","/"]>	|  < COMMA: "," >	|  < FILELISTEND : "]" > :DEFAULT}< fileListProcessing, DEFAULT, wrappedExpressionProcessing, expressionProcessing >TOKEN :{	< COLON: ":" >}< argProcessing, DEFAULT, passThruProcessing >TOKEN :{	< LITERALBLOCK: "%%{" ([" ", "\t"])* ("\n")? (~["}"] | "}" ~["%"] | "}%" ~["%"])* "}%%" > 	{	        String sss = image.toString();            int i, j;            for(j = 3; j < sss.length() && (sss.charAt(j) == ' ' || sss.charAt(j) == '\u005ct'); j++) ;            if(j < sss.length() && sss.charAt(j) == '\u005cn') j++;            for(i = sss.length()-4; i > 0 && (sss.charAt(i) == ' ' || sss.charAt(i) == '\u005ct'); i--) ;            if(i > 0 && sss.charAt(i) == '\u005cn') i++;            sss = sss.substring(j, i+1);            StringBuffer b = new StringBuffer();            boolean skipToEnd = false;            for(int p=0; p < sss.length(); p++) {            	char c = sss.charAt(p);            	if(skipToEnd) {            		if(c == '\n') {            			skipToEnd = false;            		}            	} else {            		if(c == ' ' || c == '\t')            			continue;            		skipToEnd = true;            		            	}            	b.append(c);	            }            matchedToken.image = b.toString();    } : DEFAULT    | < VARIABLE: "$$" < VARSTART > (< VARREST >)* (< WHITESPACE > | "\n") > { matchedToken.image = image.toString().trim(); } : DEFAULT    | < EXPRESSION: "$$" (~[" ", "\t", "\"", "'", "\\", "{", "\n", "\r" ] | < STRING_LITERAL> | ("'" (~["'"] | "\\'")* "'") )+ > : DEFAULT    | < #STRING_LITERAL: "\"" ( ~["\"","\\"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ))* "\"">}< DEFAULT >TOKEN :{   <  PASSTHRU: (< PASSTHRUSET >)+ > : passThruProcessing | < #PASSTHRUSET: ( ~[" ", "\t", "\n", "\r", "$" ] | ( "$" ~["$"] )) >}< passThruProcessing >TOKEN :{    < PASSTHRUMORE:  (< PASSTHRUSET >)+ ("\n")? >}< wrappedExpressionProcessing >TOKEN :{  < WRAPPEDEXPRESSION: (~["}"])* "}" > { matchedToken.image = image.toString().substring(0, image.toString().length()-1); } : DEFAULT}SelfCompilingNode script() : { }{  (	 command()  )* < EOF >  {	return (SelfCompilingNode) jjtThis;  }}void command() #void : { }{  (	  simpleCommand()	| blockCommand()	| variableAssign()  )}void simpleCommand() #void : { }{  (	  createvm()	| on()	| log()	| destroy()  )}void blockCommand() #void : { }{    forCommand()    // placeholder for future block commands}void forCommand() : { Token t; }{    t = < FORLOOP > variable() < COLON > expression() block(t.beginLine, t.beginColumn)}void variable() : { Token t; }{    t =  < VARIABLE >    {		jjtThis.jjtSetValue(t.image);  	} }void block(int blockLine, int indent) : { }{  ( LOOKAHEAD({ getToken(1).kind != EOF &&                         indent < getToken(1).beginColumn }) 	command()  )*}  void createvm(): { }{	< CREATEVM > ( option() )+ }void option() : { Token t; }{  (		( t = < OPTION > arg() )		| t = < NO_ARG_OPTION >  ) {		jjtThis.jjtSetValue(t.image);  	} }void arg() #void : { Token t; }{	literalArg()  | expression()  | fileList()}void literalArg() : { Token t; }{  (		t = < NON_SPACE_ARG >	  | t = < LITERAL_STRING >	  | t = < LITERALBLOCK >  )  {    jjtThis.jjtSetValue(t.image);  }}void on() : { }{	< ON > expression() ( option() )*  remoteShell()}void log() : { }{	< LOG >}void destroy() : { }{	< DESTROY >}void variableAssign() : { Token t; }{	t = < VARIABLEASSIGN > ( simpleCommand() | expression() )	{	  jjtThis.jjtSetValue(t.image);	}}void expression() : { Token t; }{  (		 	    t = < VARIABLE > 			{ jjtree.pushNode(getExpressionNode(t.image, t.beginLine, t.beginColumn)); }	  | t = < WRAPPEDEXPRESSION > 	{ jjtree.pushNode(getExpressionNode(t.image, t.beginLine, t.beginColumn)); }	  | t = < EXPRESSION >			{ jjtree.pushNode(getExpressionNode(t.image, t.beginLine, t.beginColumn)); }  ) {	 	if(t.specialToken != null) 	 		jjtThis.jjtSetValue(t.specialToken.image);    }}Token passThruFragment() #void : { Token t;  }{	(   t = < PASSTHRU >   	  | t = < PASSTHRUMORE > 	)	{	  return t;	}}void passThru(boolean lastWasExp) : { Token t; String result=null; Token first=null; String prefix = ""; }{	( LOOKAHEAD(1) t = passThruFragment()		{		  if(first == null)		  {		  	first = t;		  	if(lastWasExp)	{ 		  	  if(first.specialToken != null) {		  	  	prefix = first.specialToken.image;		  	  }		    }  		  }		  result = result == null ? prefix+t.image : result+" "+t.image;		}	)+	{	  jjtThis.jjtSetValue(result);	}}void remoteShell() : { boolean lastWasExp = false; }{	( 	   expression()	   {	     lastWasExp = true;	   }	 |   passThru(lastWasExp)	   {	    lastWasExp = false;	   }	) +	}void fileList() : { Map<String, String> result = new HashMap<String, String>(); Token f; Token m; }{	(  	    < FILELIST > [f = < FILESPEC > { m = f; } [ < COLON > m = < FILESPEC >] { result.put(f.image, m.image); }	    (< COMMA > f = < FILESPEC > { m = f; } [ < COLON > m = < FILESPEC >] { result.put(f.image, m.image); } )*] < FILELISTEND >	)	{	 jjtThis.jjtSetValue(result);	}}